#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_samplerless_texture_functions : require

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, r32f) uniform image2D image;
layout(binding = 2, set = 0) uniform texture2D depthImage;
layout(binding = 3, set = 0) uniform UniformBuffer
{
    mat4 invModelView;
    mat4 invProjection;
	vec4 projectionParams;
    vec4 sunDirectionAndNoiseIndex;
    uint drawWithoutNoiseFrameIndex;
} ub;
layout(binding = 4) uniform sampler3D noiseTexture;
layout(location = 0) rayPayloadEXT bool isShadowed;

float rand(vec2 co){
    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
}

const uint NOISE_TEXTURE_SIZE_PER_SIDE = 128;
const uint NOISE_TEXTURE_VECTOR_COUNT = 16;

const float PI = 3.141592f;
const float PI_x2 = PI * 2.0f;
const float HALF_PI = PI * 0.5f;

void main() 
{
    const vec2 pixelPos = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    const vec2 inUV = pixelPos / vec2(gl_LaunchSizeEXT.xy);
    vec2 d = inUV * 2.0 - 1.0;

    vec4 viewRay = ub.invProjection * vec4(d.x, d.y, 1.0, 1.0);
    float depth = texelFetch(depthImage, ivec2(gl_LaunchIDEXT.xy), 0).r;
    float linearDepth = ub.projectionParams.y / (depth - ub.projectionParams.x);
    vec3 viewPos = viewRay.xyz * linearDepth;
	vec4 rawPos = ub.invModelView * vec4(viewPos, 1.0);

    vec4 origin = rawPos;

    uint rayFlags = gl_RayFlagsOpaqueEXT;
    uint cullMask = 0xff;
    float tmin = 0.001;
    float tmax = 10000.0;

    if(ub.drawWithoutNoiseFrameIndex == 0)
    {
        isShadowed = true;

        vec3 noiseDir = (texture(noiseTexture, vec3((gl_LaunchIDEXT.xy) / float(NOISE_TEXTURE_SIZE_PER_SIDE), float(ub.sunDirectionAndNoiseIndex.w) / float(NOISE_TEXTURE_VECTOR_COUNT))).rgb);

        //mat3 rotation = mat3(cos(ub.sunDirectionAndNoiseRotation.z), 0, sin(ub.sunDirectionAndNoiseRotation.z),
        //                     0, 1, 0,
        //                     -sin(ub.sunDirectionAndNoiseRotation.z), 0, cos(ub.sunDirectionAndNoiseRotation.z));

        noiseDir *= 0.01f;

        vec3 direction = normalize(ub.sunDirectionAndNoiseIndex.xyz) + noiseDir;
        traceRayEXT(topLevelAS, rayFlags, cullMask, 0 /*sbtRecordOffset*/, 0 /*sbtRecordStride*/, 0 /*missIndex*/, origin.xyz, tmin, direction, tmax, 0 /*payload*/);

        imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(isShadowed ? 0.0 : 1.0, 0.0, 0.0, 0.0));
    }
    else
    {
        float sumShadow = 0.0f;

        vec3 up = vec3(0.0, 1.0, 0.0);
        vec3 right = vec3(1, 0, 0);

        float sampleDelta = 0.015;
        float nrSamples = 0.0;
        float start = float(ub.drawWithoutNoiseFrameIndex - 1) * 0.0625;
        float end = float(ub.drawWithoutNoiseFrameIndex) * 0.0625;
        for(uint i = uint(start * 128.0f); i < uint(end * 128.0f); i += 1)
        {
            for(uint j = 0; j < 128; j += 1)
            {
                vec3 noiseDir = (texture(noiseTexture, vec3(vec2(i, j) / float(NOISE_TEXTURE_SIZE_PER_SIDE), (int(nrSamples) % NOISE_TEXTURE_VECTOR_COUNT)/ float(NOISE_TEXTURE_VECTOR_COUNT))).rgb);
                noiseDir *= 0.01f;

                // spherical to cartesian (in tangent space)
                //vec3 tangentSample = vec3(sin(theta) * cos(phi),  cos(theta), sin(theta) * sin(phi));
                // tangent space to world
                //vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * vec3(0, 0, 1); 
                //sampleVec = normalize(sampleVec + noiseDir * 0.1f);

                //sampleVec *= 0.01f;

                isShadowed = true;

                vec3 direction = normalize(normalize(ub.sunDirectionAndNoiseIndex.xyz)) + noiseDir;
                traceRayEXT(topLevelAS, rayFlags, cullMask, 0 /*sbtRecordOffset*/, 0 /*sbtRecordStride*/, 0 /*missIndex*/, origin.xyz, tmin, direction, tmax, 0 /*payload*/);

                sumShadow += isShadowed ? 0.0 : 1.0;

                nrSamples++;
            }
        }

        float previousCounter = float(16 - ub.drawWithoutNoiseFrameIndex) * nrSamples;
        float previousColor = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).r;

        if(ub.drawWithoutNoiseFrameIndex == 16)
            previousColor = 0;

        imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(previousColor + (sumShadow / nrSamples) * 0.0625, 0.0, 0.0, 0.0));
    }
}